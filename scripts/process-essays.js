#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Function to read and parse a markdown file
function processEssayFile(filename) {
  const filePath = path.join(__dirname, '..', '_posts', filename);
  
  if (!fs.existsSync(filePath)) {
    console.error(`File not found: ${filePath}`);
    return null;
  }
  
  const content = fs.readFileSync(filePath, 'utf8');
  const slug = filename.replace(/\.markdown$/, '').replace(/^\d{4}-\d{2}-\d{2}-/, '');
  
  // Parse frontmatter
  const frontmatterRegex = /^---\n([\s\S]*?)\n---\n([\s\S]*)$/;
  const match = content.match(frontmatterRegex);
  
  if (!match) {
    console.error(`Invalid markdown format in ${filename}`);
    return null;
  }
  
  const frontmatter = match[1];
  const markdownContent = match[2];
  
  // Parse frontmatter
  const metadata = {
    title: "",
    date: "",
    categories: [],
    tags: [],
    layout: "post",
    image: ""
  };
  
  const lines = frontmatter.split('\n');
  for (const line of lines) {
    const [key, ...valueParts] = line.split(':');
    if (key && valueParts.length > 0) {
      const value = valueParts.join(':').trim();
      
      switch (key.trim()) {
        case 'title':
          metadata.title = value.replace(/"/g, '');
          break;
        case 'date':
          metadata.date = value;
          break;
        case 'categories':
          const categoriesMatch = value.match(/\[(.*)\]/);
          if (categoriesMatch) {
            metadata.categories = categoriesMatch[1].split(',').map(cat => cat.trim());
          }
          break;
        case 'tags':
          const tagsMatch = value.match(/\[(.*)\]/);
          if (tagsMatch) {
            metadata.tags = tagsMatch[1].split(',').map(tag => tag.trim());
          }
          break;
        case 'layout':
          metadata.layout = value;
          break;
        case 'image':
          metadata.image = value.replace(/"/g, '');
          break;
      }
    }
  }
  
  // Escape the content for JavaScript string
  const escapedContent = markdownContent
    .replace(/\\/g, '\\\\')
    .replace(/`/g, '\\`')
    .replace(/\$/g, '\\$');
  
  return {
    metadata,
    content: escapedContent,
    slug
  };
}

// Function to generate the essayLoader.ts file
function generateEssayLoader(essays) {
  const template = `import { parseMarkdownFile, Essay } from './markdown';

// Build-time processed essays
// This file is auto-generated by scripts/process-essays.js
const essays: Essay[] = [
${essays.map(essay => `  {
    metadata: {
      title: "${essay.metadata.title}",
      date: "${essay.metadata.date}",
      categories: [${essay.metadata.categories.map(cat => `"${cat}"`).join(', ')}],
      tags: [${essay.metadata.tags.map(tag => `"${tag}"`).join(', ')}],
      layout: "${essay.metadata.layout}",
      image: "${essay.metadata.image}"
    },
    content: \`${essay.content}\`,
    slug: "${essay.slug}"
  }`).join(',\n')}
];

// Create a map for fast lookup by slug
const essayMap = new Map<string, Essay>();
essays.forEach(essay => {
  essayMap.set(essay.slug, essay);
});

export async function getEssay(slug: string): Promise<Essay | null> {
  // Simulate async behavior for consistency
  await new Promise(resolve => setTimeout(resolve, 10));
  return essayMap.get(slug) || null;
}

export async function getAllEssays(): Promise<Essay[]> {
  // Simulate async behavior for consistency
  await new Promise(resolve => setTimeout(resolve, 10));
  
  // Sort by date (newest first)
  return [...essays].sort((a, b) => 
    new Date(b.metadata.date).getTime() - new Date(a.metadata.date).getTime()
  );
}

// Clear cache (not needed for this approach, but keeping for API consistency)
export function clearEssayCache(): void {
  // No cache to clear in this approach
}
`;

  return template;
}

// Helper to extract CSS links from dist/index.html
function getCssLinksFromDist() {
  const distIndexPath = path.join(__dirname, '..', 'dist', 'index.html');
  if (!fs.existsSync(distIndexPath)) return '';
  const html = fs.readFileSync(distIndexPath, 'utf8');
  // Match all <link rel="stylesheet" ...> tags
  const matches = html.match(/<link rel="stylesheet"[^>]*>/g);
  return matches ? matches.join('\n    ') : '';
}

// Function to generate a static HTML file for an essay
function generateEssayHtml(essay) {
  const { title, date, image } = essay.metadata;
  const htmlContent = convertMarkdownToHtml(essay.content);
  const cssLinks = getCssLinksFromDist();
  return `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>${title} | Claus Horn</title>
    <meta name="description" content="${title} - Essay by Claus Horn" />
    <link rel="icon" type="image/x-icon" href="/favicon.ico" />
    ${cssLinks}
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" />
  </head>
  <body class="bg-white text-charcoal font-sans">
    <main class="pt-20">
      <article class="pt-8 pb-20">
        <div class="section-container max-w-4xl mx-auto">
          <header class="mb-12">
            <div class="flex items-center space-x-4 text-sm text-charcoal/60 mb-6">
              <span>${new Date(date).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })}</span>
            </div>
            <h1 class="text-4xl md:text-5xl font-bold text-charcoal mb-6">${title}</h1>
            ${image ? `<div class="mb-8"><img src="/images/${image}" alt="${title}" class="w-full max-w-2xl h-48 object-cover rounded-lg" /></div>` : ''}
          </header>
          <div class="prose prose-lg max-w-none">${htmlContent}</div>
        </div>
      </article>
    </main>
  </body>
</html>`;
}

// Copy of convertMarkdownToHtml from src/utils/markdown.ts
function convertMarkdownToHtml(markdown) {
  let html = markdown;
  html = html.replace(/^### (.*$)/gim, '<h3 class="text-xl font-semibold text-charcoal mb-4">$1</h3>');
  html = html.replace(/^## (.*$)/gim, '<h2 class="text-2xl font-semibold text-charcoal mb-6">$1</h2>');
  html = html.replace(/^# (.*$)/gim, '<h1 class="text-3xl font-bold text-charcoal mb-8">$1</h1>');
  html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
  html = html.replace(/\*([^*]*?)\*/gs, '<em>$1</em>');
  html = html.replace(/```([\s\S]*?)```/g, '<pre class="bg-light-gray p-4 rounded-lg overflow-x-auto mb-4"><code>$1</code></pre>');
  html = html.replace(/`(.*?)`/g, '<code class="bg-light-gray px-1 py-0.5 rounded text-sm">$1</code>');
  html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (match, text, url) => {
    const isInternal = url.startsWith('#') || url.startsWith('/');
    const target = isInternal ? '' : 'target="_blank"';
    const rel = isInternal ? '' : 'rel="noopener noreferrer"';
    return `<a href="${url}" class="text-accent-blue hover:text-dark-red underline" ${target} ${rel}>${text}</a>`;
  });
  html = html.replace(/\[(\d+)\]/g, '<a href="#ref-$1" class="text-accent-blue hover:text-dark-red underline">[$1]</a>');
  html = html.replace(/^\* (.*$)/gim, '<li class="ml-4 mb-2">$1</li>');
  html = html.replace(/(<li.*<\/li>)/s, '<ul class="list-disc ml-6 mb-4">$1</ul>');
  html = html.replace(/^(?!<[h|u|o|p|li])(.*$)/gim, '<p class="text-charcoal/80 leading-relaxed mb-4">$1</p>');
  html = html.replace(/<p class="text-charcoal\/80 leading-relaxed mb-4"><\/p>/g, '<div class="h-4"></div>');
  return html;
}

// Main function
function main() {
  const postsDir = path.join(__dirname, '..', '_posts');
  
  if (!fs.existsSync(postsDir)) {
    console.log('Creating _posts directory...');
    fs.mkdirSync(postsDir, { recursive: true });
  }
  
  const files = fs.readdirSync(postsDir)
    .filter(file => file.endsWith('.markdown'))
    .sort((a, b) => b.localeCompare(a)); // Sort newest first
  
  console.log(`Found ${files.length} essay files:`);
  files.forEach(file => console.log(`  - ${file}`));
  
  const essays = [];
  
  for (const filename of files) {
    const essay = processEssayFile(filename);
    if (essay) {
      essays.push(essay);
      console.log(`‚úÖ Processed: ${essay.metadata.title}`);
    }
  }
  
  if (essays.length === 0) {
    console.log('No essays found. Creating a sample essay...');
    const sampleEssay = {
      metadata: {
        title: "Sample Essay",
        date: "2025-01-01",
        categories: ["Sample"],
        tags: ["Sample"],
        layout: "post"
      },
      content: "This is a sample essay. Add your own essays to the _posts directory.",
      slug: "sample"
    };
    essays.push(sampleEssay);
  }
  
  // Generate the essayLoader.ts file
  const loaderContent = generateEssayLoader(essays);
  const loaderPath = path.join(__dirname, '..', 'src', 'utils', 'essayLoader.ts');
  
  fs.writeFileSync(loaderPath, loaderContent);
  console.log(`\n‚úÖ Generated essayLoader.ts with ${essays.length} essays`);
  console.log(`üìù Essays are now available in your app!`);

  // Generate static HTML files for each essay
  const distEssaysDir = path.join(__dirname, '..', 'dist', 'essays');
  if (!fs.existsSync(distEssaysDir)) {
    fs.mkdirSync(distEssaysDir, { recursive: true });
  }
  essays.forEach(essay => {
    const essayDir = path.join(distEssaysDir, essay.slug);
    if (!fs.existsSync(essayDir)) {
      fs.mkdirSync(essayDir, { recursive: true });
    }
    const html = generateEssayHtml(essay);
    fs.writeFileSync(path.join(essayDir, 'index.html'), html);
    console.log(`‚úÖ Generated static HTML for essay: ${essay.slug}`);
  });

  // Remove SPA 404.html redirect if it exists
  const dist404 = path.join(__dirname, '..', 'dist', '404.html');
  if (fs.existsSync(dist404)) {
    fs.unlinkSync(dist404);
    console.log('üóëÔ∏è Removed SPA 404.html redirect');
  }
}

main(); 