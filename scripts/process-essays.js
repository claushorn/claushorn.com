#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Function to read and parse a markdown file
function processEssayFile(filename) {
  const filePath = path.join(__dirname, '..', '_posts', filename);
  
  if (!fs.existsSync(filePath)) {
    console.error(`File not found: ${filePath}`);
    return null;
  }
  
  const content = fs.readFileSync(filePath, 'utf8');
  const slug = filename.replace(/\.markdown$/, '').replace(/^\d{4}-\d{2}-\d{2}-/, '');
  
  // Parse frontmatter
  const frontmatterRegex = /^---\n([\s\S]*?)\n---\n([\s\S]*)$/;
  const match = content.match(frontmatterRegex);
  
  if (!match) {
    console.error(`Invalid markdown format in ${filename}`);
    return null;
  }
  
  const frontmatter = match[1];
  const markdownContent = match[2];
  
  // Parse frontmatter
  const metadata = {
    title: "",
    date: "",
    categories: [],
    tags: [],
    layout: "post",
    image: ""
  };
  
  const lines = frontmatter.split('\n');
  for (const line of lines) {
    const [key, ...valueParts] = line.split(':');
    if (key && valueParts.length > 0) {
      const value = valueParts.join(':').trim();
      
      switch (key.trim()) {
        case 'title':
          metadata.title = value.replace(/"/g, '');
          break;
        case 'date':
          metadata.date = value;
          break;
        case 'categories':
          const categoriesMatch = value.match(/\[(.*)\]/);
          if (categoriesMatch) {
            metadata.categories = categoriesMatch[1].split(',').map(cat => cat.trim());
          }
          break;
        case 'tags':
          const tagsMatch = value.match(/\[(.*)\]/);
          if (tagsMatch) {
            metadata.tags = tagsMatch[1].split(',').map(tag => tag.trim());
          }
          break;
        case 'layout':
          metadata.layout = value;
          break;
        case 'image':
          metadata.image = value.replace(/"/g, '');
          break;
      }
    }
  }
  
  // Escape the content for JavaScript string
  const escapedContent = markdownContent
    .replace(/\\/g, '\\\\')
    .replace(/`/g, '\\`')
    .replace(/\$/g, '\\$');
  
  return {
    metadata,
    content: escapedContent,
    slug
  };
}

// Function to generate the essayLoader.ts file
function generateEssayLoader(essays) {
  const template = `import { parseMarkdownFile, Essay } from './markdown';

// Build-time processed essays
// This file is auto-generated by scripts/process-essays.js
const essays: Essay[] = [
${essays.map(essay => `  {
    metadata: {
      title: "${essay.metadata.title}",
      date: "${essay.metadata.date}",
      categories: [${essay.metadata.categories.map(cat => `"${cat}"`).join(', ')}],
      tags: [${essay.metadata.tags.map(tag => `"${tag}"`).join(', ')}],
      layout: "${essay.metadata.layout}",
      image: "${essay.metadata.image}"
    },
    content: \`${essay.content}\`,
    slug: "${essay.slug}"
  }`).join(',\n')}
];

// Create a map for fast lookup by slug
const essayMap = new Map<string, Essay>();
essays.forEach(essay => {
  essayMap.set(essay.slug, essay);
});

export async function getEssay(slug: string): Promise<Essay | null> {
  // Simulate async behavior for consistency
  await new Promise(resolve => setTimeout(resolve, 10));
  return essayMap.get(slug) || null;
}

export async function getAllEssays(): Promise<Essay[]> {
  // Simulate async behavior for consistency
  await new Promise(resolve => setTimeout(resolve, 10));
  
  // Sort by date (newest first)
  return [...essays].sort((a, b) => 
    new Date(b.metadata.date).getTime() - new Date(a.metadata.date).getTime()
  );
}

// Clear cache (not needed for this approach, but keeping for API consistency)
export function clearEssayCache(): void {
  // No cache to clear in this approach
}
`;

  return template;
}

// Main function
function main() {
  const postsDir = path.join(__dirname, '..', '_posts');
  
  if (!fs.existsSync(postsDir)) {
    console.log('Creating _posts directory...');
    fs.mkdirSync(postsDir, { recursive: true });
  }
  
  const files = fs.readdirSync(postsDir)
    .filter(file => file.endsWith('.markdown'))
    .sort((a, b) => b.localeCompare(a)); // Sort newest first
  
  console.log(`Found ${files.length} essay files:`);
  files.forEach(file => console.log(`  - ${file}`));
  
  const essays = [];
  
  for (const filename of files) {
    const essay = processEssayFile(filename);
    if (essay) {
      essays.push(essay);
      console.log(`âœ… Processed: ${essay.metadata.title}`);
    }
  }
  
  if (essays.length === 0) {
    console.log('No essays found. Creating a sample essay...');
    const sampleEssay = {
      metadata: {
        title: "Sample Essay",
        date: "2025-01-01",
        categories: ["Sample"],
        tags: ["Sample"],
        layout: "post"
      },
      content: "This is a sample essay. Add your own essays to the _posts directory.",
      slug: "sample"
    };
    essays.push(sampleEssay);
  }
  
  // Generate the essayLoader.ts file
  const loaderContent = generateEssayLoader(essays);
  const loaderPath = path.join(__dirname, '..', 'src', 'utils', 'essayLoader.ts');
  
  fs.writeFileSync(loaderPath, loaderContent);
  console.log(`\nâœ… Generated essayLoader.ts with ${essays.length} essays`);
  console.log(`ğŸ“ Essays are now available in your app!`);
}

main(); 